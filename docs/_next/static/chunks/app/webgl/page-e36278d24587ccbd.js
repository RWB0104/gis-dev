(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[870],{45982:function(e,t,i){Promise.resolve().then(i.bind(i,98567)),Promise.resolve().then(i.bind(i,42352)),Promise.resolve().then(i.bind(i,53646)),Promise.resolve().then(i.t.bind(i,62372,23)),Promise.resolve().then(i.bind(i,30310)),Promise.resolve().then(i.bind(i,36280)),Promise.resolve().then(i.bind(i,17282)),Promise.resolve().then(i.bind(i,37734)),Promise.resolve().then(i.bind(i,31156))},20260:function(e,t,i){"use strict";var s=i(13767);t.Z=void 0;var o=s(i(41032)),n=i(39926),a=(0,o.default)((0,n.jsx)("path",{d:"M6 13c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-8c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm-3 .5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM6 5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm15 5.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM14 7c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0-3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zm-11 10c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm7 7c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm0-17c.28 0 .5-.22.5-.5s-.22-.5-.5-.5-.5.22-.5.5.22.5.5.5zM10 7c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm0 5.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm8 .5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-8c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0-4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm3 8.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zM14 17c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm0 3.5c-.28 0-.5.22-.5.5s.22.5.5.5.5-.22.5-.5-.22-.5-.5-.5zm-4-12c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0 8.5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm4-4.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-4c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"}),"BlurOn");t.Z=a},43485:function(e,t,i){"use strict";var s=i(13767);t.Z=void 0;var o=s(i(41032)),n=i(39926),a=(0,o.default)((0,n.jsx)("path",{d:"M10 12c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zM6 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12-8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm-4 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm4-4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-4-4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-4-4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"}),"Grain");t.Z=a},30310:function(e,t,i){"use strict";i.r(t),i.d(t,{default:function(){return g}});var s=i(39926),o=i(98594),n=i(34901),a=i(54636),r=i(50878),l=i(54839),c=i(99271),u=i.n(c),d=i(48806),p=i(10496),f=i(39647),h=i.n(f);let m=u().bind(h());function g(){let{map:e}=(0,p.useContext)(n.X),{setModal:t}=(0,a.C)(),[i,c]=(0,p.useState)(!1),u=(0,p.useCallback)(()=>{e&&(c(!0),navigator.geolocation.getCurrentPosition(t=>{let{latitude:i,longitude:s}=t.coords,o=e.getView().getProjection().getCode(),n=e.getView().getZoom()||0,a=(0,d.Z)("EPSG:4326",o,[s,i]);e.getView().animate({center:a,duration:2e3}),e.getView().animate({duration:1e3,zoom:n-3},{duration:1e3,zoom:n},()=>{c(!1)})},()=>{t({body:(0,s.jsx)(l.Z,{variant:"caption",children:"지오로케이션 호출에 실패했습니다."}),title:"지오로케이션 실패",type:"error"}),c(!1)},{enableHighAccuracy:!0}))},[e,c,t]);return(0,s.jsx)(o.Z,{bgcolor:"limegreen","data-component":"GeolocationButton",disabled:i,onClick:u,children:(0,s.jsx)(r.default,{className:m({icon:i}),htmlColor:"white"})})}},36280:function(e,t,i){"use strict";i.r(t),i.d(t,{default:function(){return l}});var s=i(39926),o=i(98594),n=i(34901),a=i(23744),r=i(10496);function l(e){let{homePosition:t}=e,{map:i}=(0,r.useContext)(n.X),[l,c]=(0,r.useState)(!1),u=(0,r.useCallback)(()=>{if(i){c(!0);let e=i.getView().getZoom()||0;i.getView().animate({center:t,duration:2e3}),i.getView().animate({duration:1e3,zoom:e-3},{duration:1e3,zoom:e},()=>{c(!1)})}},[t,i,c]);return(0,s.jsx)(o.Z,{bgcolor:"orange",disabled:l,onClick:u,children:(0,s.jsx)(a.Z,{htmlColor:"white"})})}},37734:function(e,t,i){"use strict";i.r(t),i.d(t,{default:function(){return a}});var s=i(39926),o=i(39993),n=i(92214);function a(e){let{children:t}=e;return(0,s.jsx)(o.Z,{view:n.t.seoulHighView,hasCursor:!0,children:t})}},16365:function(e,t,i){"use strict";var s=i(97503);t.Z=s.default},31156:function(e,t,i){"use strict";i.r(t),i.d(t,{default:function(){return Z}});var s=i(39926),o=i(16365),n=i(34901),a=i(27731),r=i(27067),l=i(31697),c=i(20260),u=i(43485),d=i(43160),p=i(28124),f=i(4057),h=i(16323),m=i(3853),g=i(54839),x=i(51940),v=i(37492),$=i(34031),b=i(83798),y=i(89711),S=i(9119);function w(e,t,i){let s=(0,$.Mj)();return s.style=e.style,(0,y.xA)(t,i,s,e)}function P(e){let t=(0,S._2)(e),i=256*t[0];return[i+t[1],256*t[2]+Math.round(255*t[3])]}let z=`vec4 unpackColor(vec2 packedColor) {
  return fract(packedColor[1] / 256.0) * vec4(
    fract(floor(packedColor[0] / 256.0) / 256.0),
    fract(packedColor[0] / 256.0),
    fract(floor(packedColor[1] / 256.0) / 256.0),
    1.0
  );
}`;function k(e){return e===$.Mr?2:e===$.PA?4:1}function _(e){let t=k(e);return t>1?`vec${t}`:"float"}function C(e){return(JSON.stringify(e).split("").reduce((e,t)=>(e<<5)-e+t.charCodeAt(0),0)>>>0).toString()}function R(e,t,i,s){if(`${s}radius` in e&&"icon-"!==s){let o=w(i,e[`${s}radius`],$.sw);if(`${s}radius2` in e){let t=w(i,e[`${s}radius2`],$.sw);o=`max(${o}, ${t})`}`${s}stroke-width` in e&&(o=`(${o} + ${w(i,e[`${s}stroke-width`],$.sw)} * 0.5)`),t.setSymbolSizeExpression(`vec2(${o} * 2. + 0.5)`)}if(`${s}scale` in e){let o=w(i,e[`${s}scale`],$.sw|$.PA);t.setSymbolSizeExpression(`${t.getSymbolSizeExpression()} * ${o}`)}`${s}displacement` in e&&t.setSymbolOffsetExpression(w(i,e[`${s}displacement`],$.PA)),`${s}rotation` in e&&t.setSymbolRotationExpression(w(i,e[`${s}rotation`],$.sw)),`${s}rotate-with-view` in e&&t.setSymbolRotateWithView(!!e[`${s}rotate-with-view`])}function E(e,t,i,s,o){let n="vec4(0.)";if(null!==t&&(n=t),null!==i&&null!==s){let t=`smoothstep(-${s} + 0.63, -${s} - 0.58, ${e})`;n=`mix(${i}, ${n}, ${t})`}let a=`(1.0 - smoothstep(-0.63, 0.58, ${e}))`,r=`${n} * ${a}`;return null!==o&&(r=`${r} * ${o}`),r}function D(e,t,i,s,o){let n;let a=new Image;return a.crossOrigin=void 0===e[`${s}cross-origin`]?"anonymous":e[`${s}cross-origin`],a.src=e[`${s}src`],a.complete&&a.width&&a.height?n=(0,y.ci)([a.width,a.height]):(i[`u_texture${o}_size`]=()=>a.complete?[a.width,a.height]:[0,0],t.addUniform(`vec2 u_texture${o}_size`),n=`u_texture${o}_size`),i[`u_texture${o}`]=a,t.addUniform(`sampler2D u_texture${o}`),n}function j(e,t,i,s,o){let n=w(i,e[`${t}offset`],$.PA);if(`${t}offset-origin` in e)switch(e[`${t}offset-origin`]){case"top-right":n=`vec2(${s}.x, 0.) + ${o} * vec2(-1., 0.) + ${n} * vec2(-1., 1.)`;break;case"bottom-left":n=`vec2(0., ${s}.y) + ${o} * vec2(0., -1.) + ${n} * vec2(1., -1.)`;break;case"bottom-right":n=`${s} - ${o} - ${n}`}return n}class L extends x.Z{constructor(e){super(Object.assign({},e)),this.parseResult_=function(e){let t={inFragmentShader:!1,properties:{},variables:{},functions:{},style:e},i={inFragmentShader:!0,variables:t.variables,properties:{},functions:{},style:e},s=new b.k,o={};if("icon-src"in e?function(e,t,i,s,o){let n="vec4(1.0)";"icon-color"in e&&(n=w(o,e["icon-color"],$.Mr)),"icon-opacity"in e&&(n=`${n} * ${w(o,e["icon-opacity"],$.sw)}`);let a=C(e["icon-src"]),r=D(e,t,i,"icon-",a);if(t.setSymbolColorExpression(`${n} * samplePremultiplied(u_texture${a}, v_texCoord)`).setSymbolSizeExpression(r),"icon-width"in e&&"icon-height"in e&&t.setSymbolSizeExpression(`vec2(${w(s,e["icon-width"],$.sw)}, ${w(s,e["icon-height"],$.sw)})`),"icon-offset"in e&&"icon-size"in e){let i=w(s,e["icon-size"],$.PA),o=t.getSymbolSizeExpression();t.setSymbolSizeExpression(i);let n=j(e,"icon-",s,"v_quadSizePx",i);t.setTextureCoordinateExpression(`(vec4((${n}).xyxy) + vec4(0., 0., ${i})) / (${o}).xyxy`)}if(R(e,t,s,"icon-"),"icon-anchor"in e){let i;let o=w(s,e["icon-anchor"],$.PA),n="1.0";"icon-scale"in e&&(n=w(s,e["icon-scale"],$.sw|$.PA)),i="pixels"===e["icon-anchor-x-units"]&&"pixels"===e["icon-anchor-y-units"]?`${o} * ${n}`:"pixels"===e["icon-anchor-x-units"]?`${o} * vec2(vec2(${n}).x, v_quadSizePx.y)`:"pixels"===e["icon-anchor-y-units"]?`${o} * vec2(v_quadSizePx.x, vec2(${n}).x)`:`${o} * v_quadSizePx`;let a=`v_quadSizePx * vec2(0.5, -0.5) + ${i} * vec2(-1., 1.)`;if("icon-anchor-origin"in e)switch(e["icon-anchor-origin"]){case"top-right":a=`v_quadSizePx * -0.5 + ${i}`;break;case"bottom-left":a=`v_quadSizePx * 0.5 - ${i}`;break;case"bottom-right":a=`v_quadSizePx * vec2(-0.5, 0.5) + ${i} * vec2(1., -1.)`}t.setSymbolOffsetExpression(`${t.getSymbolOffsetExpression()} + ${a}`)}}(e,s,o,t,i):"shape-points"in e?function(e,t,i,s,o){let n;o.functions.round=`float round(float v) {
  return sign(v) * floor(abs(v) + 0.5);
}`,o.functions.starDistanceField=`float starDistanceField(vec2 point, float numPoints, float radius, float radius2, float angle) {
  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle
  float c = cos(startAngle);
  float s = sin(startAngle);
  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);
  float alpha = TWO_PI / numPoints; // the angle of one sector
  float beta = atan(pointRotated.y, pointRotated.x);
  float gamma = round(beta / alpha) * alpha; // angle in sector
  c = cos(-gamma);
  s = sin(-gamma);
  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));
  vec2 tipToPoint = inSector + vec2(-radius, 0.);
  vec2 edgeNormal = vec2(radius2 * sin(alpha * 0.5), -radius2 * cos(alpha * 0.5) + radius);
  return dot(normalize(edgeNormal), tipToPoint);
}`,o.functions.regularDistanceField=`float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {
  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle
  float c = cos(startAngle);
  float s = sin(startAngle);
  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);
  float alpha = TWO_PI / numPoints; // the angle of one sector
  float radiusIn = radius * cos(PI / numPoints);
  float beta = atan(pointRotated.y, pointRotated.x);
  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid
  c = cos(-gamma);
  s = sin(-gamma);
  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));
  return inSector.x - radiusIn;
}`,R(e,t,s,"shape-");let a=null;"shape-opacity"in e&&(a=w(o,e["shape-opacity"],$.sw));let r="coordsPx";if("shape-scale"in e){let t=w(o,e["shape-scale"],$.sw|$.PA);r=`coordsPx / ${t}`}let l=null;"shape-fill-color"in e&&(l=w(o,e["shape-fill-color"],$.Mr));let c=null;"shape-stroke-color"in e&&(c=w(o,e["shape-stroke-color"],$.Mr));let u=null;"shape-stroke-width"in e&&(u=w(o,e["shape-stroke-width"],$.sw));let d=w(o,e["shape-points"],$.sw),p="0.";"shape-angle"in e&&(p=w(o,e["shape-angle"],$.sw));let f=w(o,e["shape-radius"],$.sw);if(null!==u&&(f=`${f} + ${u} * 0.5`),"shape-radius2"in e){let t=w(o,e["shape-radius2"],$.sw);null!==u&&(t=`${t} + ${u} * 0.5`),n=`starDistanceField(${r}, ${d}, ${f}, ${t}, ${p})`}else n=`regularDistanceField(${r}, ${d}, ${f}, ${p})`;let h=E(n,l,c,u,a);t.setSymbolColorExpression(h)}(e,s,0,t,i):"circle-radius"in e&&function(e,t,i,s,o){o.functions.circleDistanceField=`float circleDistanceField(vec2 point, float radius) {
  return length(point) - radius;
}`,R(e,t,s,"circle-");let n=null;"circle-opacity"in e&&(n=w(o,e["circle-opacity"],$.sw));let a="coordsPx";if("circle-scale"in e){let t=w(o,e["circle-scale"],$.sw|$.PA);a=`coordsPx / ${t}`}let r=null;"circle-fill-color"in e&&(r=w(o,e["circle-fill-color"],$.Mr));let l=null;"circle-stroke-color"in e&&(l=w(o,e["circle-stroke-color"],$.Mr));let c=w(o,e["circle-radius"],$.sw),u=null;"circle-stroke-width"in e&&(u=w(o,e["circle-stroke-width"],$.sw),c=`(${c} + ${u} * 0.5)`);let d=E(`circleDistanceField(${a}, ${c})`,r,l,u,n);t.setSymbolColorExpression(d)}(e,s,0,t,i),function(e,t,i,s,o){if("stroke-color"in e&&t.setStrokeColorExpression(w(o,e["stroke-color"],$.Mr)),"stroke-pattern-src"in e){let s=C(e["stroke-pattern-src"]),n=D(e,t,i,"stroke-pattern-",s),a=n,r="vec2(0.)";"stroke-pattern-offset"in e&&"stroke-pattern-size"in e&&(a=w(o,e["stroke-pattern-size"],$.PA),r=j(e,"stroke-pattern-",o,n,a));let l="0.";"stroke-pattern-spacing"in e&&(l=w(o,e["stroke-pattern-spacing"],$.sw)),o.functions.sampleStrokePattern=`vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio, float lineWidth) {
  float currentLengthScaled = currentLengthPx * sampleSize.y / lineWidth;
  float spacingScaled = spacingPx * sampleSize.y / lineWidth;
  float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));
  // make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels
  uCoordPx = clamp(uCoordPx, 0.5, sampleSize.x - 0.5);
  float vCoordPx = (-currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;
  vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;
  return samplePremultiplied(texture, texCoord);
}`;let c=`u_texture${s}`,u="1.";"stroke-color"in e&&(u=t.getStrokeColorExpression()),t.setStrokeColorExpression(`${u} * sampleStrokePattern(${c}, ${n}, ${r}, ${a}, ${l}, currentLengthPx, currentRadiusRatio, v_width)`)}if("stroke-width"in e&&t.setStrokeWidthExpression(w(s,e["stroke-width"],$.sw)),"stroke-offset"in e&&t.setStrokeOffsetExpression(w(s,e["stroke-offset"],$.sw)),"stroke-line-cap"in e&&t.setStrokeCapExpression(w(s,e["stroke-line-cap"],$.uW)),"stroke-line-join"in e&&t.setStrokeJoinExpression(w(s,e["stroke-line-join"],$.uW)),"stroke-miter-limit"in e&&t.setStrokeMiterLimitExpression(w(s,e["stroke-miter-limit"],$.sw)),"stroke-line-dash"in e){o.functions.getSingleDashDistance=`float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {
  float localDistance = mod(distance, dashLengthTotal);
  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;
  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);
  if (capType == ${(0,y.JB)("square")}) {
    distanceSegment -= v_width * 0.5;
  } else if (capType == ${(0,y.JB)("round")}) {
    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);
  }
  return distanceSegment;
}`;let i=e["stroke-line-dash"].map(e=>w(o,e,$.sw));i.length%2==1&&(i=[...i,...i]);let n="0.";"stroke-line-dash-offset"in e&&(n=w(s,e["stroke-line-dash-offset"],$.sw));let a=C(e["stroke-line-dash"]),r=`dashDistanceField_${a}`,l=i.map((e,t)=>`float dashLength${t} = ${e};`),c=i.map((e,t)=>`dashLength${t}`).join(" + "),u="0.",d=`getSingleDashDistance(distance, radius, ${u}, dashLength0, totalDashLength, capType)`;for(let e=2;e<i.length;e+=2)u=`${u} + dashLength${e-2} + dashLength${e-1}`,d=`min(${d}, getSingleDashDistance(distance, radius, ${u}, dashLength${e}, totalDashLength, capType))`;o.functions[r]=`float ${r}(float distance, float radius, float capType) {
  ${l.join("\n  ")}
  float totalDashLength = ${c};
  return ${d};
}`,t.setStrokeDistanceFieldExpression(`${r}(currentLengthPx + ${n}, currentRadiusPx, capType)`)}}(e,s,o,t,i),function(e,t,i,s,o){if("fill-color"in e&&t.setFillColorExpression(w(o,e["fill-color"],$.Mr)),"fill-pattern-src"in e){let s=C(e["fill-pattern-src"]),n=D(e,t,i,"fill-pattern-",s),a=n,r="vec2(0.)";"fill-pattern-offset"in e&&"fill-pattern-size"in e&&(a=w(o,e["fill-pattern-size"],$.PA),r=j(e,"fill-pattern-",o,n,a)),o.functions.sampleFillPattern=`vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {
  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);
  vec2 pxRelativePos = pxPosition - pxOrigin;
  // rotate the relative position from origin by the current view rotation
  pxRelativePos = vec2(pxRelativePos.x * cos(u_rotation) - pxRelativePos.y * sin(u_rotation), pxRelativePos.x * sin(u_rotation) + pxRelativePos.y * cos(u_rotation));
  // sample position is computed according to the sample offset & size
  vec2 samplePos = mod(pxRelativePos / scaleRatio, sampleSize);
  // also make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels
  samplePos = clamp(samplePos, vec2(0.5), sampleSize - vec2(0.5));
  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright
  return samplePremultiplied(texture, (samplePos + textureOffset) / textureSize);
}`;let l=`u_texture${s}`,c="1.";"fill-color"in e&&(c=t.getFillColorExpression()),t.setFillColorExpression(`${c} * sampleFillPattern(${l}, ${n}, ${r}, ${a}, pxOrigin, pxPos)`)}}(e,s,o,0,i),e.filter){let t=w(i,e.filter,$.wy);s.setFragmentDiscardExpression(`!${t}`)}Object.keys(i.variables).forEach(function(t){let n;let a=i.variables[t],r=(0,y.aT)(a.name);s.addUniform(`${_(a.type)} ${r}`),n=a.type===$.uW?()=>(0,y.Ce)(e.variables[a.name]):a.type===$.Mr?()=>P([...(0,S._2)(e.variables[a.name]||"#eee")]):a.type===$.wy?()=>e.variables[a.name]?1:0:()=>e.variables[a.name],o[r]=n}),Object.keys(i.properties).forEach(function(e){let o=i.properties[e];t.properties[e]||(t.properties[e]=o);let n=_(o.type),a=`a_prop_${o.name}`;o.type===$.Mr&&(n="vec4",a=`unpackColor(${a})`,s.addVertexShaderFunction(z)),s.addVarying(`v_prop_${o.name}`,n,a)}),Object.keys(t.properties).forEach(function(e){let i=t.properties[e];s.addAttribute(`${_(i.type)} a_prop_${i.name}`)});let n=Object.keys(t.properties).map(function(e){let i;let s=t.properties[e];return i=s.evaluator?s.evaluator:s.type===$.uW?e=>(0,y.Ce)(e.get(s.name)):s.type===$.Mr?e=>P([...(0,S._2)(e.get(s.name)||"#eee")]):s.type===$.wy?e=>e.get(s.name)?1:0:e=>e.get(s.name),{name:s.name,size:k(s.type),callback:i}});for(let e in t.functions)s.addVertexShaderFunction(t.functions[e]);for(let e in i.functions)s.addFragmentShaderFunction(i.functions[e]);return{builder:s,attributes:n.reduce((e,t)=>({...e,[t.name]:{callback:t.callback,size:t.size}}),{}),uniforms:o}}(e.style),this.styleVariables_=e.style.variables||{},this.hitDetectionDisabled_=!!e.disableHitDetection}createRenderer(){let e=Object.keys(this.parseResult_.attributes).map(e=>({name:e,...this.parseResult_.attributes[e]}));return new v.Z(this,{vertexShader:this.parseResult_.builder.getSymbolVertexShader(),fragmentShader:this.parseResult_.builder.getSymbolFragmentShader(),hitDetectionEnabled:!this.hitDetectionDisabled_,uniforms:this.parseResult_.uniforms,attributes:e})}updateStyleVariables(e){Object.assign(this.styleVariables_,e),this.changed()}}var O=i(10496);function Z(){let{map:e}=(0,O.useContext)(n.X),[t,i]=(0,O.useState)("webgl"),x=(0,O.useCallback)((e,t)=>{i(t)},[i]);return(0,O.useEffect)(()=>{if(e){let i=e.getAllLayers().find(e=>"wfs-webgl"===e.get("name")),s=e.getAllLayers().find(e=>"wfs"===e.get("name"));"webgl"===t?(null==i||i.setVisible(!0),null==s||s.setVisible(!1)):(null==s||s.setVisible(!0),null==i||i.setVisible(!1))}},[e,t]),(0,O.useEffect)(()=>{if(e){let t=new L({properties:{name:"wfs-webgl"},source:r.Vr.wfsCitySource,style:(0,l.Lg)(),zIndex:5}),{wfsCityVectorLayer:i}=a.wfsLayer;i.setVisible(!1),e.addLayer(t),e.addLayer(i)}},[e]),(0,s.jsxs)(o.Z,{children:[(0,s.jsxs)(m.Z,{size:"small",value:t,exclusive:!0,fullWidth:!0,onChange:x,children:[(0,s.jsx)(h.Z,{color:"webgl"===t?"primary":void 0,disabled:"webgl"===t,value:"webgl",children:(0,s.jsxs)(f.Z,{alignItems:"center",direction:"row",gap:1,children:[(0,s.jsx)(c.Z,{fontSize:"inherit"}),(0,s.jsx)(g.Z,{variant:"caption",children:"WebGL"})]})}),(0,s.jsx)(h.Z,{color:"vector"===t?"primary":void 0,disabled:"vector"===t,value:"vector",children:(0,s.jsxs)(f.Z,{alignItems:"center",direction:"row",gap:1,children:[(0,s.jsx)(u.Z,{fontSize:"inherit"}),(0,s.jsx)(g.Z,{variant:"caption",children:"Vector"})]})})]}),(0,s.jsx)(d.Z,{padding:.5,children:(0,s.jsx)(p.Z,{})})]})}},39647:function(e){e.exports={icon:"GeolocationButton_icon__O2WtR",rolling:"GeolocationButton_rolling__mgNSn"}}},function(e){e.O(0,[322,880,864,27,77,973,603,116,503,991,399,744],function(){return e(e.s=45982)}),_N_E=e.O()}]);